---
categories: algorithms
tags:
 - Java
 - 최단경로 찾기 알고리즘(Dijkstra)
---


## Description
가능한 적은 비용으로 가장 빠르게 해답에 도달하는 경로를 찾아내는 알고리즘
현재 상황에서 여러가지 경우의 수 중에 그 순간의 최선의 선택을 하는 Greedy Algorithm(탐욕 알고리즘)을 사용한다.

기본목표는 시작 노드와 나머지 그래프 사이의 최단 경로를 결정하는 것이다.
핵심은 시작 노드와 모든 가능한 대상 사이에 더 긴 경로를 연속적으로 제거하는 것이다.


![경로 예제](./etc/dijkstra1.gif)


    1. startNode까지의 거리를 0으로 설정
    2. 다른 모든 거리는 무한의 값으로 설정
    3. startNode 를 미방문노드셋에 추가하고
    4. 미방문노드셋이 비어 있지 않으면
        4-1. 셋중에 가장 가까운 거리의 노드를 검색

    1. 출발점으로부터의 최단거리를 저장할 배열 d[v]를 만들고, 출발 노드에는 0을, 
        출발점을 제외한 다른 노드들에는 매우 큰 값 INF를 채워 넣는다.
        보통은 최단거리 저장 배열의 이론상 최대값에 맞게 INF를 정한다.
        실무에서는 보통 d의 원소 타입에 대한 최대값으로 설정하는 편.
    
    2. 현재 노드 A에 출발 노드를 저장한다.
    
    3. A로부터 갈 수 있는 임의의 노드 B에 대해, d[A] + P[A][B]와 d[B]의 값을 비교한다.
    
    4. 만약 d[A] + P[A][B]가 더 짧다면, d[B]의 값을 이 값으로 갱신시킨다.
    
    5. 모든 이웃 노드 B에 대해 이 작업을 수행한다.
    
    6. A의 상태를 "방문 완료"로 바꾼다. 그러면 이제 더 이상 A는 사용하지 않는다.
    
    7. "미방문" 상태인 모든 노드들 중, 출발점으로부터의 거리가 제일 짧은 짧은 노드 하나를 골라서 그 노드를 A에 저장한다.
    
    8. 도착 노드가 "방문 완료" 상태가 되거나, 혹은 더 이상 미방문 상태의 노드를 선택할 수 없을 때까지, 3~7의 과정을 반복한다.
    
    
    이 작업을 마친 뒤, 도착 노드에 저장된 값이 바로 A로부터의 최단 거리이다. 
    만약 이 값이 INF라면, 중간에 길이 끊긴 것임을 의미한다.
    7번 단계에서, 거리가 가장 짧은 노드를 고르는 것은 공짜가 아니다.
    모든 노드를 순회해야 하므로 시간복잡도에 결정적인 영향을 미치게 되는데, 이 때 제대로 구현된[5] 우선순위 큐를 활용한다면 이 비용을 줄일 수 있다.
    최단거리를 갱신할 때 우선순위 큐에도 <위치, 거리>의 쌍을 넣어주고, 거리가 가장 짧은 노드를 우선순위 큐를 이용해 고르면 된다.
    이 비용은 삽입에 최대 O(lg N) 출력에 O(lg N)이므로, 모든 노드 순회(O(N))보다 저렴하다.  

---


## Real world examples


## Credits

